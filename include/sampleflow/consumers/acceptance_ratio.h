// ---------------------------------------------------------------------
//
// Copyright (C) 2019 by the SampleFlow authors.
//
// This file is part of the SampleFlow library.
//
// The SampleFlow library is free software; you can use it, redistribute
// it, and/or modify it under the terms of the GNU Lesser General
// Public License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// The full text of the license can be found in the file LICENSE.md at
// the top level directory of SampleFlow.
//
// ---------------------------------------------------------------------

#ifndef SAMPLEFLOW_CONSUMERS_ACCEPTANCE_RATIO_H
#define SAMPLEFLOW_CONSUMERS_ACCEPTANCE_RATIO_H

#include <sampleflow/consumer.h>
#include <sampleflow/types.h>
#include <mutex>
#include <valarray>

namespace SampleFlow
{
  namespace Consumers
  {
    /**
     * A Consumer class that implements computing the acceptance ratio
     * over all samples seen so far. The last value so computed can be
     * obtained by calling the get() function.
     *
     * The concept of acceptance/rejection of a sample is explained in the documentation of
     * the Producers::MetropolisHastings class. This calculation uses the
     * assumption that every *accepted* sample in the sampling algorithm is *different* from last one.
     *
     * With every new sample, this algorithm checks if it differs from the last one. If it differs, it adds
     * one to the counter that keeps track of the number of accepted samples. The get() function
     * then returns the number of accepted samples divided by the overall number of samples.
     *
     * ### Threading model ###
     *
     * The implementation of this class is thread-safe, i.e., its
     * consume() member function can be called concurrently and from multiple
     * threads.
     *
     * @tparam InputType The C++ type used for the samples $x_k$. All this class requires of
     *    the data type is that the comparison operator between two objects returns a `bool`. This
     *    is true for most classes, but not all. (For example, `std::valarray` returns a vector of
     *    bool values; however, this class makes sure this works nonetheless by
     *    working around this restriction for this particular
     *    class.)
     */
    template <typename InputType>
    class AcceptanceRatio : public Consumer<InputType>
    {
      public:
        /**
         * The type of the information generated by this class, i.e., in which
         * the acceptance ratio value is computed. Here, this is a floating point number.
         */
        using value_type = double;

        /**
         * Constructor.
         *
         * This class does not support asynchronous processing of samples,
         * and consequently calls the base class constructor with
         * ParallelMode::synchronous as argument.
         */
        AcceptanceRatio();

        /**
         * Destructor. This function also makes sure that all samples this
         * object may have received have been fully processed. To this end,
         * it calls the Consumers::disconnect_and_flush() function of the
         * base class.
         */
        virtual ~AcceptanceRatio ();

        /**
         * Process one sample by updating the previously computed acceptance ratio
         * using this one sample.
         *
         * @param[in] sample The sample to process.
         * @param[in] aux_data Auxiliary data about this sample. The current
         *   class does not know what to do with any such data and consequently
         *   simply ignores it.
         */
        virtual
        void
        consume (InputType     sample,
                 AuxiliaryData aux_data) override;

        /**
         * A function that returns the ratio computed from the samples
         * seen so far. If no samples have been processed so far, then a
         * zero will be returned.
         *
         * @return Acceptance ratio.
         */
        double get () const;

      private:
        /**
         * A mutex used to lock access to all member variables when running
         * on multiple threads.
         */
        mutable std::mutex mutex;

        /**
         * The current value of accepted values as described in the introduction
         * of this class.
         */
        types::sample_index n_accepted_samples;

        /**
         * The number of samples processed so far.
         */
        types::sample_index n_samples;

        /**
         * Previous sample
         */
        InputType previous_sample;
    };


    /**
     * Constructor
     */
    template <typename InputType>
    AcceptanceRatio<InputType>::
    AcceptanceRatio ()
      :
      Consumer<InputType>(ParallelMode::synchronous),
      n_samples (0),
      n_accepted_samples (0)
    {}



    template <typename InputType>
    AcceptanceRatio<InputType>::
    ~AcceptanceRatio ()
    {
      this->disconnect_and_flush();
    }



    namespace internal
    {
      namespace AcceptanceRatio
      {
        /**
         * A function that compares two objects of arbitrary type for
         * equality. It does so by using `operator==`.
         *
         * There are specializations of this function below that are used
         * for certain types for which `operator==` does not, in fact,
         * return a single boolean.
         */
        template <typename T>
        bool is_equal (const T &t1,
                       const T &t2)
        {
          return (t1==t2);
        }


        /**
         * A function that compares two `std::valarray` objects for
         * equality. This function works around the fact that `std::valarray`'s
         * `operator==` doesn't just return a single boolean, but in fact
         * a `std::valarray<bool>` -- for reasons that are probably lost
         * to history given how bad a choice that is.
         */
        template <typename T>
        bool is_equal (const std::valarray<T> &t1,
                       const std::valarray<T> &t2)
        {
          if (t1.size() != t2.size())
            return false;

          for (unsigned int i=0; i<t1.size(); ++i)
            if (t1[i] != t2[i])
              return false;

          return true;
        }

      }
    }



    template <typename InputType>
    void
    AcceptanceRatio<InputType>::
    consume (InputType sample, AuxiliaryData /*aux_data*/)
    {
      std::lock_guard<std::mutex> lock(mutex);

      // If this is the first sample we see, naturally, this sample is accepted.
      if (n_samples == 0)
        {
          n_samples          = 1;
          n_accepted_samples = 1;
          previous_sample    = sample;
        }
      else
        // Check if new sample is not equal to previous sample and
        // if that is true add one to accept.
        {
          if (internal::AcceptanceRatio::is_equal(sample, previous_sample))
            {
              // The two samples are equal. That is, we have not received
              // a new "accepted" sample and don't need to update either
              // the stored sample or the number of accepted samples.
              ++n_samples;
            }
          else
            {
              // The new sample is different. Update the counter and store
              // the new sample.
              ++n_accepted_samples;
              previous_sample = sample;
              ++n_samples;
            }
        }
    }



    template <typename InputType>
    double
    AcceptanceRatio<InputType>::
    get () const
    {
      std::lock_guard<std::mutex> lock(mutex);

      if (n_samples > 0)
        return (static_cast<double>(n_accepted_samples)
                /
                static_cast<double>(n_samples));
      else
        return 0.0;
    }
  }
}

#endif
