// ---------------------------------------------------------------------
//
// Copyright (C) 2019 by the SampleFlow authors.
//
// This file is part of the SampleFlow library.
//
// The SampleFlow library is free software; you can use it, redistribute
// it, and/or modify it under the terms of the GNU Lesser General
// Public License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// The full text of the license can be found in the file LICENSE.md at
// the top level directory of SampleFlow.
//
// ---------------------------------------------------------------------

#ifndef SAMPLEFLOW_CONSUMERS_PAIR_PairHistogram_H
#define SAMPLEFLOW_CONSUMERS_PAIR_PairHistogram_H

#include <sampleflow/consumer.h>
#include <sampleflow/types.h>

#include <boost/numeric/ublas/matrix.hpp>

#include <mutex>
#include <type_traits>
#include <vector>
#include <array>
#include <tuple>
#include <cmath>
#include <algorithm>
#include <ostream>
#include <functional>
#include <cassert>


namespace SampleFlow
{
  namespace Consumers
  {
    /**
     * A Consumer class that implements the creation of a joint histogram of
     * two components of vector-valued samples. This pair histogram can then
     * be obtained by calling the get() function. The sample type needs to
     * have exactly two components for this class to work.
     *
     * If a sample falls exactly on the boundary between bins, this
     * class may count it for one or the other bin and users should
     * not rely on a particular behavior by choosing interval break points
     * that are not likely going to be sample points. For example, if sample
     * components are integer-valued, then the intervals should be chosen
     * to be from $n-0.5$ to $n+0.5$ for integers $n$.
     *
     *
     * ### Threading model ###
     *
     * The implementation of this class is thread-safe, i.e., its
     * consume() member function can be called concurrently and from multiple
     * threads.
     *
     *
     * @tparam InputType The C++ type used for the samples $x_k$ processed
     *   by this class. In order to compute a PairHistogram, this type must
     *   (i) represent vectors of some form that allow taking components
     *   using `operator[]`, and each component has to allow
     *   an ordering, or more specifically, putting values into bins.
     *   This is asserted by ensuring that the type of each component satisfies
     *   the `std::is_arithmetic` property of C++11. If you have a sample type
     *   that consists of more than two components, for example if
     *   $x_k \in {\mathbb R}^n$ with $n>2$, then one can of course still
     *   generate histograms for each combination of two vector components.
     *   To this end, you can use the Filter implementation of
     *   the Filters::ComponentPairSplitter class that extracts a pair of
     *   components from a vector; this component splitter object would then
     *   be a filter placed between the original Producer of the vector-valued
     *   samples and this Consumer of vector-valued samples with exactly
     *   two components.
     */
    template <typename InputType>
    class PairHistogram : public Consumer<InputType>
    {
      public:
        static_assert (Utilities::internal::has_subscript_operator<InputType>::value == true,
                       "This class can only be used for vector-like types that "
                       "allow applying the [] operator to obtain individual "
                       "components");
        static_assert (Utilities::internal::has_size_function<InputType>::value == true,
                       "This class can only be used for vector-like types that "
                       "have a size() member function.");
        static_assert (std::is_arithmetic<types::ScalarType<InputType>>::value == true,
                       "This class can only be used with vector-like types "
                       "whose components are arithmetic, i.e., which can be "
                       "ordered.");

        /**
         * The type of the information generated by this class, i.e., the type
         * of the object returned by get(). In the current case, this is a vector
         * of triplets; the vector has one entry for each bin, and each bin
         * is represented by three elements:
         * - The bottom left point of the bin, as represented by a std::array
         *   of two doubles representing the two coordinates.
         * - The top right point of the bin.
         * - The number of samples in the bin.
         * You can access these three elements for the $i$th bin using code
         * such as
         * @code
         *   const auto bottom_left  = std::get<0>(PairHistogram.get()[i]);
         *   const auto top_right    = std::get<1>(PairHistogram.get()[i]);
         *   const SampleFlow::types::sample_index
         *          n_samples_in_bin = std::get<2>(PairHistogram.get()[i]);
         * @endcode
         */
        using value_type = std::vector<std::tuple<std::array<double,2>,std::array<double,2>,types::sample_index>>;

        /**
         * Constructor for a PairHistogram that is equally spaced in real space.
         *
         * This class does not care in which order samples are processed, and
         * consequently calls the base class constructor with
         * `ParallelMode::synchronous | ParallelMode::asynchronous` as argument.
         *
         * @param[in] min_x_value The left end point of the range over which the
         *   first coordinate of the
         *   PairHistogram should be generated. Samples that have a value less than
         *   this end point will simply not be counted.
         * @param[in] max_x_value The right end point of the range over which the
         *   PairHistogram should be generated. Samples that have a value larger than
         *   this end point will simply not be counted.
         * @param[in] n_x_bins The number of bins this class represents for the first
         *   coordinate, i.e., how many sub-intervals the range
         *   `min_x_value...max_x_value` will be split in.
         * @param[in] min_y_value The parameter corresponding to `min_x_value` except
         *   for the second coordinate axis.
         * @param[in] max_y_value The parameter corresponding to `max_x_value` except
         *   for the second coordinate axis.
         * @param[in] n_y_bins  The parameter corresponding to `n_x_bins` except
         *   for the second coordinate axis.
         */
        PairHistogram (const double min_x_value,
                       const double max_x_value,
                       const unsigned int n_x_bins,
                       const double min_y_value,
                       const double max_y_value,
                       const unsigned int n_y_bins);

        /**
         * Constructor for a PairHistogram that is equally spaced in some pre-image
         * space of a function and whose bins are then transformed using the
         * function provided by the user as the last argument. The way this
         * function works is by building a set of bins equally spaced between
         * `min_pre_value` and `max_pre_value` (with the number of bins given
         * by `n_bins`), and then transforming the left and right end points
         * of the bin intervals using the function `f`. For example, if one
         * called this constructor with arguments `(-3,3,4,&exp10)`, then
         * the bins to be used for the samples would be as follows given
         * that `exp10(x)` equals $10^x$:
         * `[0.001,10^{-1.5}]`, `[10^{-1.5},0]`, `[0,10^{1.5}]`, `[10^{1.5}, 1000]`.
         * Such bins would show up equispaced when plotted on a logarithmic
         * $x$ axis.
         *
         * @param[in] min_x_pre_value The left end point of the range over which the
         *   first coordinate of the PairHistogram should be generated,
         *   before transformation with the function
         *   `f_x`. Samples that have a value less than
         *   `f_x(min_x_pre_value)` will simply not be counted.
         * @param[in] max_x_pre_value The right end point of the range over which the
         *   first coordinate of the PairHistogram should be generated,
         *   before transformation with the function
         *   `f_x`. Samples that have a value larger than
         *   `f_x(max_x_pre_value)` will simply not be counted.
         * @param[in] n_x_bins The number of bins in the first coordinate that
         *   this class represents, i.e., how many sub-intervals the range
         *   `min_x_value...max_x_value` will be split in for the first coordinate.
         * @param[in] f_x The function used in the transformation of the first
         *   coordinate. For this set up of bins to make sense, `f_x` needs to be
         *   a strictly monotonically increasing function on the range
         *   `[min_x_pre_values,max_x_pre_values]`.
         * @param[in] min_y_pre_value Like `min_x_pre_value`,
         *   but for the second coordinate axis.
         * @param[in] max_y_pre_value Like `max_x_pre_value`,
         *   but for the second coordinate axis.
         * @param[in] n_y_bins Like `n_x_bins`, but for the second coordinate axis.
         * @param[in] f_y Like `f_x`, but for the second coordinate axis.
         */
        PairHistogram (const double min_x_pre_value,
                       const double max_x_pre_value,
                       const unsigned int n_x_bins,
                       const std::function<double (const double)> &f_x,
                       const double min_y_pre_value,
                       const double max_y_pre_value,
                       const unsigned int n_y_bins,
                       const std::function<double (const double)> &f_y);

        /**
         * Copy constructor.
         */
        PairHistogram (const PairHistogram<InputType> &o);

        /**
         * Destructor. This function also makes sure that all samples this
         * object may have received have been fully processed. To this end,
         * it calls the Consumers::disconnect_and_flush() function of the
         * base class.
         */
        virtual ~PairHistogram ();

        /**
         * Process one sample by computing which bin it lies in, and then
         * incrementing the number of samples in the bin.
         *
         * @param[in] sample The sample to process.
         * @param[in] aux_data Auxiliary data about this sample. The current
         *   class does not know what to do with any such data and consequently
         *   simply ignores it.
         */
        virtual
        void
        consume (InputType sample, AuxiliaryData aux_data) override;

        /**
         * Return the PairHistogram in the format discussed in the documentation
         * of the `value_type` type.
         *
         * @return The information that completely characterizes the PairHistogram.
         */
        value_type
        get () const;

        /**
         * Write the PairHistogram into a file in such a way that it can
         * be visualized using the Gnuplot program. Internally, this function
         * calls get() and then converts the result of that function into a
         * format understandable by Gnuplot.
         *
         * In Gnuplot, you can then visualize the content of such a file using
         * the commands
         * @code
         *   set style data lines
         *   set hidden3d
         *   splot "PairHistogram.txt"
         * @endcode
         * assuming that the data has been written into a file called
         * `PairHistogram.txt`.
         *
         * @param[in,out] output_stream An rvalue reference to a stream object
         *   into which the data will be written. Because it is an rvalue, and
         *   not an lvalue reference, it is possible to write code such as
         *   @code
         *     PairHistogram.write_gnuplot(std::ofstream("PairHistogram.txt"));
         *   @endcode
         */
        void
        write_gnuplot (std::ostream &&output_stream) const;

      private:
        /**
         * A mutex used to lock access to all member variables when running
         * on multiple threads.
         */
        mutable std::mutex mutex;

        /**
         * A variable that describes the left end points of each of the
         * intervals that make up each bin. The vector contains one additional
         * element that denotes the right end point of the last interval.
         */
        std::vector<double> x_interval_points;
        std::vector<double> y_interval_points;

        /**
         * A vector storing the number of samples so far encountered in each
         * of the bins of the PairHistogram.
         */
        boost::numeric::ublas::matrix<types::sample_index> bins;

        /**
         * For a given `value`, compute the number of the bin it lies
         * in, taking into account the way the bins subdivide the
         * range for which a PairHistogram is to be computed.
         *
         * If the given value lies to the left of the left-most interval,
         * or the right of the right-most interval, then this function will
         * abort.
         */
        unsigned int x_bin_number (const double value) const;
        unsigned int y_bin_number (const double value) const;
    };



    template <typename InputType>
    PairHistogram<InputType>::
    PairHistogram (const double min_x_value,
                   const double max_x_value,
                   const unsigned int n_x_bins,
                   const double min_y_value,
                   const double max_y_value,
                   const unsigned int n_y_bins)
      :
      Consumer<InputType>(ParallelMode(static_cast<int>(ParallelMode::synchronous)
                                       |
                                       static_cast<int>(ParallelMode::asynchronous))),
      x_interval_points(n_x_bins+1),
      y_interval_points(n_y_bins+1),
      bins (n_x_bins, n_y_bins)
    {
      // First treat the subdivision of the x-axis:
      {
        assert (min_x_value < max_x_value);

        // Set up the break points between the bins:
        const double delta = (max_x_value - min_x_value) / (n_x_bins);
        for (unsigned int bin=0; bin<n_x_bins; ++bin)
          x_interval_points[bin] = min_x_value + bin*delta;

        // And add the past-the-end interval's left end point as well:
        x_interval_points[n_x_bins] = max_x_value;
      }

      // Then do the exact same thing for the y-axis:
      {
        assert (min_y_value < max_y_value);

        const double delta = (max_y_value - min_y_value) / (n_y_bins);
        for (unsigned int bin=0; bin<n_y_bins; ++bin)
          y_interval_points[bin] = min_y_value + bin*delta;

        y_interval_points[n_y_bins] = max_y_value;

      }
    }


    template <typename InputType>
    PairHistogram<InputType>::
    PairHistogram (const double min_x_pre_value,
                   const double max_x_pre_value,
                   const unsigned int n_x_bins,
                   const std::function<double (const double)> &f_x,
                   const double min_y_pre_value,
                   const double max_y_pre_value,
                   const unsigned int n_y_bins,
                   const std::function<double (const double)> &f_y)
      :
      Consumer<InputType>(ParallelMode(static_cast<int>(ParallelMode::synchronous)
                                       |
                                       static_cast<int>(ParallelMode::asynchronous))),
      x_interval_points(n_x_bins+1),
      y_interval_points(n_y_bins+1),
      bins (n_x_bins, n_y_bins)
    {
      // Treat the x-axis subdivision:
      {
        assert (min_x_pre_value < max_x_pre_value);

        // Set up the break points between the bins:
        const double delta = (max_x_pre_value - min_x_pre_value) / (n_x_bins);
        for (unsigned int bin=0; bin<n_x_bins; ++bin)
          x_interval_points[bin] = f_x(min_x_pre_value + bin*delta);

        // And add the past-the-end interval's left end point as well:
        x_interval_points[n_x_bins] = f_x(max_x_pre_value);


        // Double check that the mapping used was indeed strictly
        // increasing:
        for (unsigned int bin=0; bin<n_x_bins; ++bin)
          {
            assert (x_interval_points[bin] < x_interval_points[bin+1]);
          }
      }

      // Treat the y-axis subdivision the same way:
      {
        assert (min_y_pre_value < max_y_pre_value);

        const double delta = (max_y_pre_value - min_y_pre_value) / (n_y_bins);
        for (unsigned int bin=0; bin<n_y_bins; ++bin)
          y_interval_points[bin] = f_y(min_y_pre_value + bin*delta);

        y_interval_points[n_y_bins] = f_y(max_y_pre_value);


        for (unsigned int bin=0; bin<n_y_bins; ++bin)
          {
            assert (y_interval_points[bin] < y_interval_points[bin+1]);
          }
      }
    }



    template <typename InputType>
    PairHistogram<InputType>::
    PairHistogram (const PairHistogram<InputType> &o)
      :
      Consumer<InputType>(ParallelMode(static_cast<int>(ParallelMode::synchronous)
                                       |
                                       static_cast<int>(ParallelMode::asynchronous))),
      x_interval_points(o.x_interval_points),
      y_interval_points(o.y_interval_points),
      bins (o.bins)
    {}



    template <typename InputType>
    PairHistogram<InputType>::
    ~PairHistogram ()
    {
      this->disconnect_and_flush();
    }



    template <typename InputType>
    void
    PairHistogram<InputType>::
    consume (InputType sample, AuxiliaryData /*aux_data*/)
    {
      assert (sample.size() == 2);

      // If a sample lies outside the bounds, just discard it:
      if (sample[0]<x_interval_points.front() || sample[0]>=x_interval_points.back())
        return;
      if (sample[1]<y_interval_points.front() || sample[1]>=y_interval_points.back())
        return;

      // Otherwise we need to update the appropriate PairHistogram bin:
      const unsigned int x_bin = x_bin_number(sample[0]);
      const unsigned int y_bin = y_bin_number(sample[1]);

      if (x_bin >= 0  &&  x_bin < bins.size1()
          &&
          y_bin >= 0  &&  y_bin < bins.size2())
        {
          std::lock_guard<std::mutex> lock(mutex);

          ++bins(x_bin,y_bin);
        }
    }



    template <typename InputType>
    typename PairHistogram<InputType>::value_type
    PairHistogram<InputType>::
    get () const
    {
      // First create the output table and breakpoints. We can do
      // this without holding the lock since we're not accessing
      // information that is subject to change when a new sample
      // comes in.
      value_type return_value (bins.size1() * bins.size2());

      for (unsigned int x_bin=0; x_bin<bins.size1(); ++x_bin)
        for (unsigned int y_bin=0; y_bin<bins.size2(); ++y_bin)
          {
            const unsigned int bin = x_bin * bins.size2() + y_bin;
            std::get<0>(return_value[bin]) = {x_interval_points[x_bin], y_interval_points[y_bin]};
            std::get<1>(return_value[bin]) = {x_interval_points[x_bin+1], y_interval_points[y_bin+1]};
          }

      // Now fill the bin sizes under a lock as they are subject to
      // change from other threads:
      std::lock_guard<std::mutex> lock(mutex);
      for (unsigned int x_bin=0; x_bin<bins.size1(); ++x_bin)
        for (unsigned int y_bin=0; y_bin<bins.size2(); ++y_bin)
          {
            const unsigned int bin = x_bin * bins.size2() + y_bin;
            std::get<2>(return_value[bin]) = bins(x_bin,y_bin);
          }

      return return_value;
    }



    template <typename InputType>
    void
    PairHistogram<InputType>::
    write_gnuplot(std::ostream &&output_stream) const
    {
      const auto PairHistogram = get();

      // Each bin of the histogram one gets from get() can be interpreted
      // as a column in x-y space. Plot it as such for gnuplot: We need
      // the four lines coming from the x-y-plane to the top surface,
      // plus the four lines that connect them at the top. But we also want
      // gnuplot to be able to to use hidden line removal, so we really
      // have to plot everything as rectangles, rather than just as lines.
      //
      // gnuplot has a peculiar form of wanting rectangles described to
      // it. In the current case, each rectangle is described as a patch
      // of 2x2 lines of points in 3d space separated by one line between
      // each set of 2 lines; then each rectangle is separated from the
      // others by two empty lines.
      for (const auto &bin : PairHistogram)
        {
          const auto bottom_left = std::get<0>(bin);
          const auto top_right   = std::get<1>(bin);
          const double x[2] = {bottom_left[0], top_right[0]};
          const double y[2] = {bottom_left[1], top_right[1]};

          const auto height      = std::get<2>(bin);

          // front surface
          output_stream << x[0] << ' ' << y[0] << ' ' << 0 << '\n'
                        << x[1] << ' ' << y[0] << ' ' << 0 << '\n'
                        << '\n'
                        << x[0] << ' ' << y[0] << ' ' << height << '\n'
                        << x[1] << ' ' << y[0] << ' ' << height << '\n'
                        << "\n\n";

          // back surface
          output_stream << x[0] << ' ' << y[1] << ' ' << 0 << '\n'
                        << x[1] << ' ' << y[1] << ' ' << 0 << '\n'
                        << '\n'
                        << x[0] << ' ' << y[1] << ' ' << height << '\n'
                        << x[1] << ' ' << y[1] << ' ' << height << '\n'
                        << "\n\n";

          // left surface
          output_stream << x[0] << ' ' << y[0] << ' ' << 0 << '\n'
                        << x[0] << ' ' << y[1] << ' ' << 0 << '\n'
                        << '\n'
                        << x[0] << ' ' << y[0] << ' ' << height << '\n'
                        << x[0] << ' ' << y[1] << ' ' << height << '\n'
                        << "\n\n";

          // right surface
          output_stream << x[1] << ' ' << y[0] << ' ' << 0 << '\n'
                        << x[1] << ' ' << y[1] << ' ' << 0 << '\n'
                        << '\n'
                        << x[1] << ' ' << y[0] << ' ' << height << '\n'
                        << x[1] << ' ' << y[1] << ' ' << height << '\n'
                        << "\n\n";

          // bottom surface
          output_stream << x[0] << ' ' << y[0] << ' ' << 0 << '\n'
                        << x[1] << ' ' << y[0] << ' ' << 0 << '\n'
                        << '\n'
                        << x[1] << ' ' << y[0] << ' ' << 0 << '\n'
                        << x[1] << ' ' << y[1] << ' ' << 0 << '\n'
                        << "\n\n";

          // top surface
          output_stream << x[0] << ' ' << y[0] << ' ' << height << '\n'
                        << x[1] << ' ' << y[0] << ' ' << height << '\n'
                        << '\n'
                        << x[0] << ' ' << y[1] << ' ' << height << '\n'
                        << x[1] << ' ' << y[1] << ' ' << height << '\n'
                        << "\n\n";
        }

      output_stream << std::flush;
    }



    template <typename InputType>
    unsigned int
    PairHistogram<InputType>::
    x_bin_number (const double value) const
    {
      assert (value >= x_interval_points.front() && value < x_interval_points.back());

      // Find the first element in interval_points that is not < value
      const auto p = std::lower_bound(x_interval_points.begin(), x_interval_points.end(),
                                      value);

      // We could have just hit an interval point exactly. We
      // generally don't care about that and just count the sample for
      // the previous interval, but can't do that if it is the
      // leftmost end point
      if (p == x_interval_points.begin())
        return 0;
      else
        return (p-x_interval_points.begin()-1);
    }



    template <typename InputType>
    unsigned int
    PairHistogram<InputType>::
    y_bin_number (const double value) const
    {
      assert (value >= y_interval_points.front() && value < y_interval_points.back());

      // Find the first element in interval_points that is not < value
      const auto p = std::lower_bound(y_interval_points.begin(), y_interval_points.end(),
                                      value);

      // We could have just hit an interval point exactly. We
      // generally don't care about that and just count the sample for
      // the previous interval, but can't do that if it is the
      // leftmost end point
      if (p == y_interval_points.begin())
        return 0;
      else
        return (p-y_interval_points.begin()-1);
    }
  }
}

#endif
